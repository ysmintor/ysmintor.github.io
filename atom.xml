<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[York's Home]]></title>
  <link href="ysmintor.github.io/atom.xml" rel="self"/>
  <link href="ysmintor.github.io/"/>
  <updated>2019-04-05T18:51:06+08:00</updated>
  <id>ysmintor.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[基于 Gradle 远程连接Hadoop HDFS编程]]></title>
    <link href="ysmintor.github.io/15543961787923.html"/>
    <updated>2019-04-05T00:42:58+08:00</updated>
    <id>ysmintor.github.io/15543961787923.html</id>
    <content type="html">
<![CDATA[<p>在一个现代化的编程时代，界面不好看的 <code>Eclipse</code> 和操作易用性相比而言更高的 <code>IntelliJ Idea</code>。而在进行 Hadoop 进行编程的时候，最基本的是需要导入相应的 Jar 包，而更为便捷的则是使用 Maven 来进行包的依赖管理，而本文则结合 Gradle 来处理引入最基本的 Hadoop 包，配置运行环境。</p>

<h2 id="toc_0">新建一个 Gradle 项目</h2>

<p>在新建时要选择 Gradle 项目，并在连接过程中自动下载 Gradle。<br/>
<img src="media/15543961787923/1.new_gradle_projects.png" alt="Step1 new_gradle_projects"/><br/>
<span id="more"></span><!-- more --></p>

<p>在下一步中，要输入一个类似于下图的 GroupId，ArtifactId，这其实是基于 Maven 结构的，关于这个如何比较正确填写可以参考<br/>
<a href="https://maven.apache.org/guides/mini/guide-naming-conventions.html">Guide to naming conventions on groupId, artifactId, and version</a><br/>
<img src="media/15543961787923/2.group_artifactid_version.png" alt="Step2 group_artifactid_version" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<p>接下来相应的配置可以直接进入下一步，配置如下，如果需要自动导包功能也可以选择<br/>
<img src="media/15543961787923/3.other_configure.png" alt="Step3 other_configure" class="mw_img_center" style="width:500px;display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">在 Maven Repository 中查找相应的依赖</h2>

<p>通过<a href="https://mvnrepository.com">Maven Repository</a>中搜索Apache Hadoop Common并查找当前连接对应的 Hadoop 版本，我目前使用的是2.8.5，所以就找到了对应于2.8.5的版本,并在下面的代码框中选择 Gradle，默认是 Maven 导入的代码，切换后可以看到是一行代码<code>compile group: &#39;org.apache.hadoop&#39;, name: &#39;hadoop-common&#39;, version: &#39;2.8.5&#39;</code><br/>
<img src="media/15543961787923/15544282060716.jpg" alt="hadoop common gradle" style="width:1132px;"/></p>

<p>按照同样的方式还需要引入Apache Hadoop HDFS,查找对应的依赖代码<br/>
<code>compile group: &#39;org.apache.hadoop&#39;, name: &#39;hadoop-hdfs&#39;, version: &#39;2.8.5&#39;</code><br/>
<img src="media/15543961787923/15544285829430.jpg" alt="" style="width:1128px;"/></p>

<h2 id="toc_2">将依赖代码填入</h2>

<p>打开项目文件，在 Project 视图中找到<code>build.gradle</code>文件，并在 dependencies 中填入刚刚从 Maven Repository 中找到了两个依赖，当你输入后，IDE 会自动通过网络下载对应的依赖，所以相应的烦琐的依赖及其相互依赖关系，通过 Gradle 能够很好地避免，整个过事其实是非常简单，只要实际尝试后，后面再去操作都变得十分容易。<br/>
<img src="media/15543961787923/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-05%20%E4%B8%8A%E5%8D%889.45.43.png" alt="填入依赖"/></p>

<h2 id="toc_3">新建文件并测试</h2>

<p>这里我自己通过新建一个<code>HDFSCreateFile</code>用来在 HDFS 文件系统创建一个名为test2的文件，文件内容则是Hello World。注意这里我修改了相应的 HDFS 文件系统地址，修改为<code>hdfs://192.168.1.199:9000</code>，是因为在局域网中我创建了了一真实的分布式文件系统，分为一个 master 节点和三个 slave 节点，而对于的名称节点即 master 节点对于的地址是<code>192.168.1.199</code>，当前的开发环境是在 Mac 下开发，如果你开发环境就是在对应的 master 节点，那么就可以用 <code>localhost</code> 或者<code>127.0.0.1</code>来处理。另外则是一般的文档说在和 HDFS 操作时创建了一个特殊用户名，如 Hadoop这类的，如果你运行程序的当前用户不是这个名称，需要提前在 HDFS 中创建对应的用户目录，否则运行程序会报权限错误。<br/>
具体代码</p>

<pre><code class="language-java">import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;


public class HDFSCreateFile {
    public static void main(String[] args){
        try{
            Configuration conf = new Configuration();
                conf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://192.168.1.199:9000&quot;);
                conf.set(&quot;fs.hdfs.impl&quot;,&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;);
                FileSystem fs = FileSystem.get(conf);
                byte[] buff = &quot;Hello World&quot;.getBytes();
                String fileName = &quot;/test2&quot;;
                FSDataOutputStream os =fs.create(new Path(fileName));
                os.write(buff,0,buff.length);
                System.out.println(&quot;Create:&quot;+fileName);
                os.close();
                fs.close();         
        } catch (Exception e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<h1 id="toc_4">总结</h1>

<p>相对于<code>Eclipse</code>,使用<code>IntelliJ Idea</code>显得更为现代感，功能上觉得两者都能实现。而<code>Eclipse</code>则更省资源，<code>IntelliJ Idea</code>使用上更为便捷。使用<code>Gradle</code>来进入依赖管理，可以省出更多时间专注于逻辑代码，解决不同包的依赖问题。</p>
]]>
    </content>
  </entry>
  
</feed>
